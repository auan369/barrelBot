#pragma config(Sensor, in1,    sharpLeft,      sensorAnalog)
#pragma config(Sensor, in2,    sharpRight,     sensorAnalog)
#pragma config(Sensor, in3,    sharpTop,       sensorAnalog)
#pragma config(Sensor, in4,    sharpBack,      sensorAnalog)
#pragma config(Sensor, in5,    irFL,           sensorAnalog)
#pragma config(Sensor, in6,    irFR,           sensorAnalog)
#pragma config(Sensor, in7,    irBL,           sensorAnalog)
#pragma config(Sensor, in8,    irBR,           sensorAnalog)
#pragma config(Sensor, dgtl1,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  ballLimit,      sensorTouch)
#pragma config(Sensor, dgtl6,  leftLimit,      sensorTouch)
#pragma config(Sensor, dgtl7,  rightLimit,     sensorTouch)
#pragma config(Sensor, dgtl8,  topLimit,       sensorTouch)
#pragma config(Sensor, dgtl9,  compassWest,    sensorDigitalIn)
#pragma config(Sensor, dgtl10, compassSouth,   sensorDigitalIn)
#pragma config(Sensor, dgtl11, compassEast,    sensorDigitalIn)
#pragma config(Sensor, dgtl12, compassNorth,   sensorDigitalIn)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port4,           barrelMotor,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           barrelServo,   tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NORTH 0
#define NORTHEAST 1
#define EAST 2
#define SOUTHEAST 3
#define SOUTH 4
#define SOUTHWEST 5
#define WEST 6
#define NORTHWEST 7

/*---------------------Global Variables-----------------------*/
string console;
int global_orientation;
int sharpLeftVal;
int sharpRightVal;
int sharpTopVal;
int sharpBackVal;
int irFLVal;
int irFRVal;
int irBLVal;
int irBRVal;
int ballLimitVal;
int leftLimitVal;
int rightLimitVal;
int topLimitVal;
int stage_of_search = 0;
int sharpSense;
int turnTime;
int compassWestVal;
int compassEastVal;
int compassNorthVal;
int compassSouthVal;
/*-------------------Default Function Declration---------------------------------*/

void move(int direction, int speedMode);
void rotate(int direction, int speedMode);
void lookForBall();
void read_orientation();
void align_orientation_with_collection_and_return();
void updateSensors();
void lineDetection();
/*-------------------State Variables---------------------------------*/
bool search = false;
bool alignedBase = false;


task main()
{
	motor[barrelMotor] = 127;
	while(1){
		//updateSensors();
		//lookForBall();
		//align_orientation_with_collection_and_return();


		lineDetection();
    if(SensorValue[ballLimit]==1){
        align_orientation_with_collection_and_return();
    }
    else{
        lookForBall();
    }


	}



}


/*-------------------Default Function Defination---------------------------------*/

void move(int direction, int speedMode)
{
	int voltageLeft;
	int voltageRight;
	if(speedMode==1)
	{
		voltageLeft=30;
		voltageRight=30;
	}
	else if(speedMode==2)
	{
		voltageLeft=60;
		voltageRight=60;
	}
	else if(speedMode==3)
	{
		voltageLeft=127;
		voltageRight=127;
	}
	else if(speedMode==0)
	{
		voltageLeft=0;
		voltageRight=0;
	}
	motor[rightMotor] = voltageRight*direction;
	motor[leftMotor]  = voltageLeft*direction;

}

void rotate(int direction, int speedMode) //ccw =1 , cw =-1
{
	int voltage;
	if(speedMode==1)
	{
		voltage=50;
	}
	else if(speedMode==2)
	{
		voltage=100;
	}
	else if(speedMode==0)
	{
		voltage=0;
	}
	motor[rightMotor] = voltage*direction;
	motor[leftMotor]  = -voltage*direction;
}

void read_orientation()
{
	int temp = 8*SensorValue(compassWest)+4*SensorValue(compassSouth)+2*SensorValue(compassEast)+SensorValue(compassNorth);
	switch(temp) {
	case 14:
		global_orientation = NORTH;
		break;
	case 13:
		global_orientation = EAST;
		break;
	case 11:
		global_orientation = SOUTH;
		break;
	case 7:
		global_orientation = WEST;
		break;
	case 12:
		global_orientation = NORTHEAST;
		break;
	case 9:
		global_orientation = SOUTHEAST;
		break;
	case 3:
		global_orientation = SOUTHWEST;
		break;
	case 6:
		global_orientation = NORTHWEST;
		break;
	default:
		global_orientation = -1;
	}
}

//bool stage_of_search=0; 0 is looking, 1 is L sense & waiting, 2 is R sense & turning back, 3 is aligned and moving forward
void lookForBall(){
		sharpTopVal = SensorValue[sharpTop];
		sharpLeftVal = SensorValue[sharpLeft];
		sharpRightVal = SensorValue[sharpRight];
    if (stage_of_search == 0){
        rotate(1,1);
        //motor[rightMotor]=50;
        //motor[leftMotor]=-50;
        console = "lookB";

        if (SensorValue[sharpLeft]>500 && SensorValue[sharpRight]<500){
            console = "Lsense";
            stage_of_search = 1;
            sharpSense = SensorValue[sharpLeft];
            //leftSense=true;
            clearTimer(T1);
        }
    }
    else if (stage_of_search == 1){
        console = "WaitR";
        if (time1[T1]<3000){
            if(SensorValue[sharpTop]>sharpSense)
            {
                clearTimer(T1);
                //leftSense = false;
                //ballfound = false;
                console = "Tsense";
                stage_of_search = 0;

            }
            else if(SensorValue[sharpRight]>500 && SensorValue[sharpLeft]<500)
            {
                console = "Rsense";
                turnTime = time1[T1];
                clearTimer(T1);
                //leftSense = false;
                //ballfound = true;
                move(1,0);
                stage_of_search = 2;
            }
        }
        else
        {
            //leftSense = false;
            stage_of_search = 0;
        }
    }
    else if (stage_of_search == 2){
        if(time1[T1]>turnTime){
			//ballfound = false;
			console = "forward";
            clearTimer(T1);
            move(1,0);
			stage_of_search = 3;
		}
		else{
			rotate(-1,1);
		}
    }
    else{
        if (time1[T1]<5000){
            move(1,1);
        }
        else{
            move(1,0);
            stage_of_search = 0;
        }
    }
}

void lookForBall2(){
		sharpTopVal = SensorValue[sharpTop];
		sharpLeftVal = SensorValue[sharpLeft];
		sharpRightVal = SensorValue[sharpRight];
    if (stage_of_search == 0){
        rotate(1,1);
        //motor[rightMotor]=50;
        //motor[leftMotor]=-50;
        console = "lookB";

        if (SensorValue[sharpLeft]>500 && (SensorValue[sharpLeft]-SensorValue[sharpRight])>100){
            console = "Lsense";
            stage_of_search = 1;
            sharpSense = SensorValue[sharpLeft];
            //leftSense=true;
            clearTimer(T1);
        }
    }
    else if (stage_of_search == 1){
        console = "WaitR";
        if (time1[T1]<3000){
            if(SensorValue[sharpTop]>sharpSense)
            {
                clearTimer(T1);
                //leftSense = false;
                //ballfound = false;
                console = "Tsense";
                stage_of_search = 0;

            }
            else if(SensorValue[sharpRight]>500 && (SensorValue[sharpRight]-SensorValue[sharpLeft])>100)
            {
                console = "Rsense";
                turnTime = time1[T1];
                clearTimer(T1);
                //leftSense = false;
                //ballfound = true;
                move(1,0);
                stage_of_search = 2;
            }
        }
        else
        {
            //leftSense = false;
            stage_of_search = 0;
        }
    }
    else if (stage_of_search == 2){
        if(time1[T1]>turnTime){
			//ballfound = false;
			console = "forward";
            clearTimer(T1);
            move(1,0);
			stage_of_search = 3;
		}
		else{
			rotate(-1,1);
		}
    }
    else{
        if (time1[T1]<5000){
            move(1,1);
        }
        else{
            move(1,0);
            stage_of_search = 0;
        }
    }



}



void align_orientation_with_collection_and_return()
{
	//rotate to align the orientation with the collection place, rotates to North, when not 0
    read_orientation();
	if(global_orientation==7||global_orientation==6||global_orientation==5)
	{//NW,W,SW
		alignedBase = false;
		rotate(-1,1);//CW

	}
	else if(global_orientation==1||global_orientation==2||global_orientation==3||global_orientation==4)
	{//NE,E,SE,S
		alignedBase = false;
		rotate(1,1);//CCW

	}

	else{
		move(-1,2);
		alignedBase = true;

	}
}

void updateSensors(){
    compassWestVal = SensorValue[compassWest];
    compassEastVal = SensorValue[compassEast];
    compassNorthVal = SensorValue[compassNorth];
    compassSouthVal = SensorValue[compassSouth];
	sharpLeftVal = SensorValue[sharpLeft];
	sharpRightVal= SensorValue[sharpRight];
	sharpTopVal= SensorValue[sharpTop];
	sharpBackVal= SensorValue[sharpBack];
	irFLVal= SensorValue[irFL];
	irFRVal= SensorValue[irFR];
	irBLVal= SensorValue[irBL];
	irBRVal= SensorValue[irBR];
	ballLimitVal= SensorValue[ballLimit];
	leftLimitVal= SensorValue[leftLimit];
	rightLimitVal= SensorValue[rightLimit];
	topLimitVal= SensorValue[topLimit];
}

void lineDetection(){
	irFLVal = SensorValue[irFL];
	irFRVal = SensorValue[irFR];
	if (SensorValue[irFL]<300 && SensorValue[irFR]<300)
		{
			move(1,0);
			move(-1,1);
			wait1Msec(1000);
			rotate(-1,1);
			wait1Msec(3000);
			move(1,1);
			//wait1Msec(1000);
	}
	else if (SensorValue[irFL]<300)
		{
			console	= "leftIR";
			move(1,0);
			move(-1,1);
			wait1Msec(1000);
			rotate(-1,1);
			wait1Msec(1500);
			move(1,1);
			wait1Msec(1000);
			move(1,0);
	}
	else if (SensorValue[irFR]<300)
		{
			console	= "rightIR";
			move(1,0);
			move(-1,1);
			wait1Msec(1000);
			rotate(1,1);
			wait1Msec(1500);
			move(1,1);
			wait1Msec(1000);
			move(1,0);
	}





}
