#pragma config(Sensor, in1,    sharpLeft,      sensorAnalog)
#pragma config(Sensor, in2,    sharpRight,     sensorAnalog)
#pragma config(Sensor, in3,    sharpTop,       sensorAnalog)
#pragma config(Sensor, in4,    sharpBack,      sensorAnalog)
#pragma config(Sensor, in5,    irFL,           sensorAnalog)
#pragma config(Sensor, in6,    irFR,           sensorAnalog)
#pragma config(Sensor, in7,    irBL,           sensorAnalog)
#pragma config(Sensor, in8,    irBR,           sensorAnalog)
#pragma config(Sensor, dgtl1,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  ballLimit,      sensorTouch)
#pragma config(Sensor, dgtl6,  leftLimit,      sensorTouch)
#pragma config(Sensor, dgtl7,  rightLimit,     sensorTouch)
#pragma config(Sensor, dgtl8,  topLimit,       sensorTouch)
#pragma config(Sensor, dgtl9,  compassWest,    sensorDigitalIn)
#pragma config(Sensor, dgtl10, compassSouth,   sensorDigitalIn)
#pragma config(Sensor, dgtl11, compassEast,    sensorDigitalIn)
#pragma config(Sensor, dgtl12, compassNorth,   sensorDigitalIn)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port4,           barrelMotor,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           barrelServo,   tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NORTH 0
#define NORTHEAST 1
#define EAST 2
#define SOUTHEAST 3
#define SOUTH 4
#define SOUTHWEST 5
#define WEST 6
#define NORTHWEST 7

/*---------------------Global Variables-----------------------*/
string console;
int global_orientation;
int sharpLeftVal;
int sharpRightVal;
int sharpTopVal;
int sharpBackVal;
int irFLVal;
int irFRVal;
int irBLVal;
int irBRVal;
int ballLimitVal;
int leftLimitVal;
int rightLimitVal;
int topLimitVal;
int stage_of_search = 0;
int sharpSense;
int turnTime;
int compassWestVal;
int compassEastVal;
int compassNorthVal;
int compassSouthVal;
/*-------------------Default Function Declration---------------------------------*/

void move(int direction, int speedMode);
void rotate(int direction, int speedMode);
void lookForBall();
void lookForBall2();
void lookForBall3();
void read_orientation();
void align_orientation_with_collection_and_return();
void updateSensors();
void lineDetection();
void releaseBall();
void resetServo();
/*-------------------State Variables---------------------------------*/
bool waitStart = true;
bool alignedBase = false;
bool ballInCage = false;
bool moveForward = true;


void testMain(){
    resetServo();
	while(waitStart){ //initialisation stage
		if (SensorValue[ballLimit]==1){
			//updateSensors();
			waitStart = false;
			clearTimer(T2);
		}
        else{
            updateSensors();
        }
	}

	while(1){ //main code

		lineDetection();
		read_orientation();
		if(ballInCage){
			align_orientation_with_collection_and_return();
		}
		else{
			if(moveForward){
				if(time1[T2]>3000){
					moveForward = false;
					clearTimer(T2);
				}
				else{
					move(1,3);
				}
			}
			else{
				if(global_orientation==0){
					moveForward = true;
					clearTimer(T2);
				}
				else{
					lookForBall3();
				}
			}
		}

	}
}

task main()
{
    while(1){
        //complete the following functions in this order, fix each as per required


        updateSensors();
        // read_orientation();
        // lineDetection();
        // align_orientation_with_collection_and_return();
        // lookForBall3();
        // testMain();

    }

    //testMain();


}


/*-------------------Default Function Defination---------------------------------*/

void move(int direction, int speedMode)
{
	int voltageLeft;
	int voltageRight;
	if(speedMode==1)
	{
		voltageLeft=30;
		voltageRight=30;
	}
	else if(speedMode==2)
	{
		voltageLeft=60;
		voltageRight=60;
	}
	else if(speedMode==3)
	{
		voltageLeft=127;
		voltageRight=127;
	}
	else if(speedMode==0)
	{
		voltageLeft=0;
		voltageRight=0;
	}
	motor[rightMotor] = voltageRight*direction;
	motor[leftMotor]  = voltageLeft*direction;

}

void rotate(int direction, int speedMode) //ccw =1 , cw =-1
{
	int voltage;
	if(speedMode==1)
	{
		voltage=50;
	}
	else if(speedMode==2)
	{
		voltage=100;
	}
	else if(speedMode==0)
	{
		voltage=0;
	}
	motor[rightMotor] = voltage*direction;
	motor[leftMotor]  = -voltage*direction;
}

void read_orientation()
{
	int temp = 8*SensorValue(compassWest)+4*SensorValue(compassSouth)+2*SensorValue(compassEast)+SensorValue(compassNorth);
	switch(temp) {
	case 14:
		global_orientation = NORTH;
		break;
	case 13:
		global_orientation = EAST;
		break;
	case 11:
		global_orientation = SOUTH;
		break;
	case 7:
		global_orientation = WEST;
		break;
	case 12:
		global_orientation = NORTHEAST;
		break;
	case 9:
		global_orientation = SOUTHEAST;
		break;
	case 3:
		global_orientation = SOUTHWEST;
		break;
	case 6:
		global_orientation = NORTHWEST;
		break;
	default:
		global_orientation = -1;
	}
}

//bool stage_of_search=0; 0 is looking, 1 is L sense & waiting, 2 is R sense & turning back, 3 is aligned and moving forward
void lookForBall(){
		sharpTopVal = SensorValue[sharpTop];
		sharpLeftVal = SensorValue[sharpLeft];
		sharpRightVal = SensorValue[sharpRight];
    if (stage_of_search == 0){
        rotate(1,1);
        //motor[rightMotor]=50;
        //motor[leftMotor]=-50;
        console = "lookB";

        if (SensorValue[sharpLeft]>500 && SensorValue[sharpRight]<500){
            console = "Lsense";
            stage_of_search = 1;
            sharpSense = SensorValue[sharpLeft];
            //leftSense=true;
            clearTimer(T1);
        }
    }
    else if (stage_of_search == 1){
        console = "WaitR";
        if (time1[T1]<3000){
            if(SensorValue[sharpTop]>sharpSense)
            {
                clearTimer(T1);
                //leftSense = false;
                //ballfound = false;
                console = "Tsense";
                stage_of_search = 0;

            }
            else if(SensorValue[sharpRight]>500 && SensorValue[sharpLeft]<500)
            {
                console = "Rsense";
                turnTime = time1[T1];
                clearTimer(T1);
                //leftSense = false;
                //ballfound = true;
                move(1,0);
                stage_of_search = 2;
            }
        }
        else
        {
            //leftSense = false;
            stage_of_search = 0;
        }
    }
    else if (stage_of_search == 2){
        if(time1[T1]>turnTime){
			//ballfound = false;
			console = "forward";
            clearTimer(T1);
            move(1,0);
			stage_of_search = 3;
		}
		else{
			rotate(-1,1);
		}
    }
    else{
        if (time1[T1]<5000){
            move(1,1);
        }
        else{
            move(1,0);
            stage_of_search = 0;
        }
    }
}

void lookForBall3(){
	sharpTopVal = SensorValue[sharpTop];
	sharpLeftVal = SensorValue[sharpLeft];
	sharpRightVal = SensorValue[sharpRight];
	motor[barrelMotor] = 127;
	if (SensorValue[ballLimit]==1){
		ballInCage = true;
		motor[barrelMotor] = 0;
	}
	else{
		ballInCage = false;
	}


    if (stage_of_search == 0){
        rotate(1,2);
        //motor[rightMotor]=50;
        //motor[leftMotor]=-50;
        console = "lookB";

        if (SensorValue[sharpLeft]>500 && (SensorValue[sharpLeft]-SensorValue[sharpRight])>100){
            console = "Lsense";
            stage_of_search = 1;
            sharpSense = SensorValue[sharpLeft];
            //leftSense=true;
            clearTimer(T1);
        }
    }
    else if (stage_of_search == 1){
        console = "WaitR";
        if (time1[T1]<3000){
            if(SensorValue[sharpTop]>sharpSense)
            {
                clearTimer(T1);
                //leftSense = false;
                //ballfound = false;
                console = "Tsense";
                stage_of_search = 0;

            }
            else if(SensorValue[sharpRight]>500 && (SensorValue[sharpRight]-SensorValue[sharpLeft])>100)
            {
                console = "Rsense";
                turnTime = time1[T1];
                clearTimer(T1);
                //leftSense = false;
                //ballfound = true;
                move(1,0);
                stage_of_search = 2;
            }
        }
        else
        {
            //leftSense = false;
            stage_of_search = 0;
        }
    }
    else if (stage_of_search == 2){
        if(time1[T1]>turnTime){
			//ballfound = false;
			console = "forward";
            clearTimer(T1);
            move(1,0);
			stage_of_search = 3;
		}
		else{
			rotate(-1,2);
		}
    }
    else if (stage_of_search == 3){
        if (time1[T1]<5000){
            move(1,3);
        }
        else{
            move(1,0);
			clearTimer(T1);
            stage_of_search = 4;
        }
    }
	else{//stage of search = 4
		if(time1[T1]>turnTime){
			move(1,0);
            stage_of_search = 0;
		}
		else{
			rotate(-1,2);
		}


	}



}



void align_orientation_with_collection_and_return()
{
	//rotate to align the orientation with the collection place, rotates to North, when not 0
    read_orientation();
	if(global_orientation==7||global_orientation==6||global_orientation==5)
	{//NW,W,SW
		alignedBase = false;
		rotate(-1,1);//CW

	}
	else if(global_orientation==1||global_orientation==2||global_orientation==3||global_orientation==4)
	{//NE,E,SE,S
		alignedBase = false;
		rotate(1,1);//CCW

	}

	else{
		move(-1,2);
		alignedBase = true;
		if(SensorValue[rightLimit]==1){ //if reach base
			wait1Msec(1000); // reverse 1 second more
			move(1,0);
			releaseBall();

			resetServo();
			ballInCage = false;
			wait1Msec(1000);
		}


	}
}

void updateSensors(){
    compassWestVal = SensorValue[compassWest];
    compassEastVal = SensorValue[compassEast];
    compassNorthVal = SensorValue[compassNorth];
    compassSouthVal = SensorValue[compassSouth];
	sharpLeftVal = SensorValue[sharpLeft];
	sharpRightVal= SensorValue[sharpRight];
	sharpTopVal= SensorValue[sharpTop];
	sharpBackVal= SensorValue[sharpBack];
	irFLVal= SensorValue[irFL];
	irFRVal= SensorValue[irFR];
	irBLVal= SensorValue[irBL];
	irBRVal= SensorValue[irBR];
	ballLimitVal= SensorValue[ballLimit];
	leftLimitVal= SensorValue[leftLimit];
	rightLimitVal= SensorValue[rightLimit];
	topLimitVal= SensorValue[topLimit];
}

void lineDetection(){
	irFLVal = SensorValue[irFL];
	irFRVal = SensorValue[irFR];
	irBRVal = SensorValue[irBR];
	irBLVal = SensorValue[irBL];
	// if (SensorValue[irFL]<300 && SensorValue[irFR]<300)
	// 	{
	// 		move(1,0);
	// 		move(-1,1);
	// 		wait1Msec(1000);
	// 		rotate(-1,1);
	// 		wait1Msec(3000);
	// 		move(1,1);
	// 		//wait1Msec(1000);
	// }
	if (SensorValue[irFL]<300)
		{
			console	= "leftIR";
			move(1,0);
			move(-1,1);
			wait1Msec(1000);
			rotate(-1,1);
			wait1Msec(1500);
			move(1,1);
			wait1Msec(1000);
			move(1,0);
	}
	else if (SensorValue[irFR]<300)
		{
			console	= "rightIR";
			move(1,0);
			move(-1,1);
			wait1Msec(1000);
			rotate(1,1);
			wait1Msec(1500);
			move(1,1);
			wait1Msec(1000);
			move(1,0);
	}
    /*
    else if (SensorValue[irBL]<300)
		{
			console	= "leftBackIR";
			move(1,0);
			move(1,1);
			wait1Msec(1000);
			rotate(1,1);
			wait1Msec(1500);
			move(-1,1);
			wait1Msec(1000);
			move(1,0);
	}
	else if (SensorValue[irBR]<300)
		{
			console	= "rightBackIR";
			move(1,0);
			move(1,1);
			wait1Msec(1000);
			rotate(-1,1);
			wait1Msec(1500);
			move(-1,1);
			wait1Msec(1000);
			move(1,0);
	}
    */


}

void releaseBall(){
	while(motor[barrelServo]>-70)
	{
		motor[barrelServo]= motor[barrelServo]-1;
		wait1Msec(10);
	}
	wait1Msec(2000);
}

void resetServo(){
	while(motor[barrelServo]<100)
	{
		motor[barrelServo]= motor[barrelServo]+1;
		wait1Msec(10);

	}
	wait1Msec(500);
}
